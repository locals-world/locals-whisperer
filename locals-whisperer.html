<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<script src="../jsencrypt/bin/jsencrypt.min.js"></script>

<!--
Whisper listener component

Example:

    <locals-whisperer></locals-whisperer>

@element locals-whisperer
@demo demo/index.html
-->
<dom-module id="locals-whisperer">
  <template>  
  </template>
</dom-module>

<script>
Polymer({

  is: 'locals-whisperer',

  properties: {

    web3: {
      type: Object,
      observer: '_web3'
    },
    // the current topic we're listening to
    topic: {
      type: Number,
      observer: '_topic',
      value: null,
      notify: true
    },
    // progress is a value between 0 and 100 denoting how much time until next topic will be generated
    // 0 = period start ; 100 = period is over
    progress: {
      type: Number,
      notify: true
    },

    // How many decimals should the topic have ( min 2 )
    decimals: {
      type: Number,
      value: 5
    },

    identity: {
      type: String,
      notify: true
    },

  },

  // Element Lifecycle

  ready: function() {
    // `ready` is called after all elements have been configured, but
    // propagates bottom-up. This element's children are ready, but parents
    // are not.
    //
    // This is the point where you should make modifications to the DOM (when
    // necessary), or kick off any processes the element wants to perform.
    this.mode = 'view';
    this.timerval = 0;
    this.holding = false;

    this.channels = {};
    this.securechannels = {};

    setInterval(this.timer.bind(this), 1000);

  },

  _getpincode: function(decimals) {


    if (decimals < 2) {
      decimals = 2;
    }
    l = Math.pow(10, decimals - 1);
    var rnd = Math.floor(Math.random() * (l * 9)) + l - 1;
    return (("chan"  + rnd).toString());
  },

  // Triggering this function holds on to the current value for 5 minutes.
  hold: function() {
    if (!this.holding) {
      this.holding = true;
      this.timerval -= 5 * 60;
    }
  },

  timer: function() {
    if (this.topic == null) {
      this.topic = this._getpincode(this.decimals);
    }
    this.timerval++;

    if (this.timerval < 0) {
      this.progress = 0;
    } else {
      this.progress = Math.floor(this.timerval / 60 * 100);
    }

    if (this.timerval >= 5 * 60) {
      this.topic = this._getpincode(this.decimals);
      this.timerval = 0;
    }
  },

  openchannel: function() {
    var _pin = this._getpincode(20);

    if (this.web3 && this.topic) {

      this.channels[_pin] = {
        filter: this.web3.shh.filter({
          "topics": [this.web3.fromAscii(_pin)],
        }),
        status: 'handshake'
      };

      console.log("locals-whisperer: channelswitch, creating channel ", _pin);

      this.channels[_pin].filter.watch(function(error, result) {
        if (!error) {
          var payload = JSON.parse(this.web3.toAscii(result.payload));
          this.fire('msg-received', {
            topic: payload.topic,
            payload: JSON.parse(payload.input)
          });
        }else{
          console.log('error watching',error);
        }
      }.bind(this));

      return _pin;
    } else {
      return;
    }
  },

  closechannel: function(_pin){
    if (this.channels[_pin]){
       this.channels[_pin].filter.stopWatching();
    }
  },

  attached: function() {

  },

  detached: function() {
    this.stopfilter();
  },

  stopfilter: function() {
    if (this.filter) {
      console.log('locals-whisperer: stop watching current channel')
      this.filter.stopWatching();
    }
  },

  // Element Behavior

  _is: function(a, b) {
    if (b === undefined) {
      b = true;
    }
    return a === b;
  },

  _web3: function() {
    var self = this;
    console.log('web3 started');
  },

  _topic: function() {
    var self = this;

    if (this.web3 && this.topic) {

      this.stopfilter();

      var topic = this.topic.toString();
      //console.log(typeof topic);
      this.filter = this.web3.shh.filter({
        "topics": [this.web3.fromAscii(topic)],
      });

      console.log("locals-whisperer: channelswitch, start listening to", this.topic);

      this.filter.watch(function(error, result) {

        if (!error) {
          var payload = JSON.parse(self.web3.toAscii(result.payload));


          switch (payload.command) {

            case 'requestaes':
              var crypt = new JSEncrypt({
                default_key_size: 512
              });
              crypt.setPublicKey(payload.pubkey);

              var aeskey = self._generateKey(50);

              var encryptedkey = crypt.encrypt(aeskey);

              self.securechannels[payload.from] = {
                aeskey: aeskey
              };

              self.raw_whisperpost(payload.from, {
                command: 'aes',
                encryptedaes: encryptedkey,
                from: self.topic
              });

              break;
            case 'aes':
              debugger;
              console.log(self.securechannels[payload.from]);
//              payload.encryptedaes.crypt
            
            default:
              self.fire('msg-received', payload);
          }

        }
      });
    }
  },

  _generateKey: function(keyLength) {
    var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz*&-%/!?*+=()";
    var randomstring = '';

    for (var i = 0; i < keyLength; i++) {
      var rnum = Math.floor(Math.random() * chars.length);
      randomstring += chars.substring(rnum, rnum + 1);
    }
    return randomstring;
  },

  _web3: function() {
    var self = this;
    console.log('web3 started');
  },

  whisperpost: function(topic, input) {

    topic = topic.toString();

    if (!this.securechannels[topic] || this.securechannels[topic] !== 'established' ){
      // Create a secure tunnel

      var c = new JSEncrypt({
        default_key_size: 512
      });

      this.securechannels[topic] = {
        crypt: c,
        messagequeue: [input]     
      };

      this.raw_whisperpost(topic,{
        command: 'requestaes',
        pubkey: this.securechannels[topic].crypt.getPublicKey(),
        from: this.topic
      });
    }

  },
  // unencrypted whisper post..
  raw_whisperpost: function(topic, input) {
    if (!this.identity) {
      this.identity = this.web3.shh.newIdentity();
    }
    var options = {
      "from": this.identity,
      "topics": [this.web3.fromAscii(topic)],
      "payload": this.web3.fromAscii(JSON.stringify(input)),
      "ttl": 100,
      "priority": 1000
    };

    return this.web3.shh.post(options, function(err, res) {
      console.log(err, res);
    });
  }


});

</script>
